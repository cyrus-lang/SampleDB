import std::libc{
    printf, fprintf, malloc,
    strncpy, free, realloc,
    stderr, strdup
};
import utils;

public INITIAL_TABLE_CAPACITY: const size_t = 16;
public MAX_TABLE_NAME_LEN: const int = 64;
public MAX_COL_NAME_LEN: const int = 64;

public enum DataType {
    Int,
    Text
}

public union ValueData {
    int_value: int;
    text_value: char*;
}

public struct Value {
    public ty: DataType;
    public data: ValueData;
}

public struct Row { 
    public values: Value*;
}

public struct Column {
    public name: char[MAX_COL_NAME_LEN];
    public ty: DataType;
}

public struct Table {
    public name: char[MAX_TABLE_NAME_LEN];
    public rows: Row**;
    public schema: Column*;
    public column_count: int;
    public row_count: int;
    public capacity: size_t;

    public func create(name: const char*, schema: Column*, column_count: int) Table* {
        if (!name || !schema || column_count == 0) {
            return null;
        }
        
        #table: Table* = malloc(sizeof(Table));
        if (!table) {
            utils::panic("failed to allocate memory for table.");
        }

        strncpy(table->name, name, MAX_TABLE_NAME_LEN);
        table->name[MAX_TABLE_NAME_LEN - 1] = '\0'; 

        table->schema = schema;
        table->column_count = column_count;
        table->capacity = INITIAL_TABLE_CAPACITY;

        table->schema = cast(Column*, malloc(sizeof(Column) * cast(size_t, column_count)));
        if (!table->schema) {
            utils::panic("failed to allocate memory for table schema.");
            free(table);
            return null;
        }

        table->rows = cast(Row**, malloc(table->capacity * sizeof(Row*)));
        if (!table->rows) {
            utils::panic("failed to allocate memory for table rows.");
            free(table->schema);
            free(table);
            return null;
        }

        return null;
    }

    public func free(&self) {
        free(self->rows);
        free(self->schema);
        free(self);
    }

    public func insert(&self, values: Value*) int {
        // check if we need to resize the table
        if (self->row_count >= cast(int, self->capacity)) {
            // double the capacity
            #new_capacity = cast(int, self->capacity) * 2;
            #resize_result = self->resize(new_capacity);

            if (resize_result != 0) {
                utils::panic("failed to resize table, insertion aborted.");
                return -1;
            }
        }

        #new_row = cast(Row*, malloc(sizeof(Row)));
        if (!new_row) {
            utils::panic("failed to allocate memory for new row.");
            return -1;
        }

        new_row->values = cast(Value*, malloc(sizeof(Value) * cast(size_t, self->column_count)));
        if (!new_row->values) {
            utils::panic("failed to allocate memory for new row values.");
            free(new_row);
            return -1;
        }

        for (#i: int = 0; i < self->column_count; i++) {
            if (values[i].ty != self->schema[i].ty) {
                fprintf(stderr, "schema mismatch at column %zu. Insertion failed!\n", i);
                free(new_row->values);
                free(new_row);
                return -1;
            }

            new_row->values[i].ty = values[i].ty;
            
            // duplicate string value
            if (values[i].ty == DataType.Text) {
                new_row->values[i].data.text_value = strdup(values[i].data.text_value);
                
                if (!new_row->values[i].data.text_value) {
                    utils::panic("failed to duplicate string for new row.");
                    for (#j: int = 0; j < i; j++) {
                        // cleanup partially created row
                        if (new_row->values[j].ty == DataType.Text) {
                            free(new_row->values[j].data.text_value);
                        }
                    }
                    free(new_row->values);
                    free(new_row);
                    return -1;
                }
            } else {
                new_row->values[i].data = values[i].data;
            }
        }

        self->rows[self->row_count] = new_row;
        self->row_count++;

        return 0;
    }

    public func print(&self) {
        utils::panic("not implemented yet.");
    }

    func resize(&self, new_capacity: size_t) int {
        printf("Resizing table %s from %d to %d\n", self->name, self->capacity, new_capacity);

        #new_rows: Row** = cast(Row**, realloc(self->rows, new_capacity * sizeof(Row*)));
        if (!new_rows) {
            utils::panic("failed to resize table rows.");
            return -1;
        }

        self->rows = new_rows;
        self->capacity = new_capacity;

        return 0;
    }
}
