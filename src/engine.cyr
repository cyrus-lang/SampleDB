import std::libc{printf, fprintf, malloc, strncpy, free, realloc, stderr};
import utils;

public INITIAL_TABLE_CAPACITY: const size_t = 16;
public MAX_TABLE_NAME_LEN: const int = 64;
public MAX_COL_NAME_LEN: const int = 64;

public enum DataType {
    Int,
    Text
}

public union ValueData {
    int_value: int;
    text_value: char*;
}

public struct Value {
    public ty: DataType;
    public data: ValueData;
}

public struct Row { 
    public values: Value*;
}

public struct Column {
    public name: char[MAX_COL_NAME_LEN];
}

public struct Table {
    public name: char[MAX_TABLE_NAME_LEN];
    public rows: Row**;
    public schema: Column*;
    public column_count: int;
    public row_count: int;
    public capacity: size_t;

    public func create(name: const char*, schema: Column*, column_count: int) Table* {
        // if (!name || !schema || column_count == 0) {
        //     return null;
        // }
        
        #table: Table* = malloc(sizeof(Table));
        if (!table) {
            utils::panic("failed to allocate memory for table.");
        }

        strncpy(table->name, name, MAX_TABLE_NAME_LEN);
        table->name[MAX_TABLE_NAME_LEN - 1] = '\0'; 

        table->schema = schema;
        table->column_count = column_count;
        table->capacity = INITIAL_TABLE_CAPACITY;

        table->schema = cast(Column*, malloc(sizeof(Column) * cast(size_t, column_count)));
        if (!table->schema) {
            utils::panic("failed to allocate memory for table schema.");
            free(table);
            return null;
        }

        table->rows = cast(Row**, malloc(table->capacity * sizeof(Row*)));
        if (!table->rows) {
            utils::panic("failed to allocate memory for table rows.");
            free(table->schema);
            free(table);
            return null;
        }

        return null;
    }

    public func free(&self) {
        free(self->rows);
        free(self->schema);
        free(self);
    }

    public func insert(&self, values: Value*) int {
        // if (self->row_count >= cast(int, self->capacity)) {
        //     // double the capacity
        //     #new_capacity = cast(int, self->capacity) * 2;
            
        //     self->resize(0);

        //     if (resize_result != 0) {
        //         utils::panic("failed to resize table, insertion aborted.");
        //         return -1;
        //     }
        // }

        #new_row = cast(Row*, malloc(sizeof(Row)));
        if (!new_row) {
            utils::panic("failed to allocate memory for new row.");
            return -1;
        }

        new_row->values = cast(Value*, malloc(sizeof(Value) * cast(size_t, self->column_count)));
        if (!new_row->values) {
            utils::panic("failed to allocate memory for new row values.");
            free(new_row);
            return -1;
        }

        for (#i: int = 0; i < self->column_count; i++) {
            if (values[i].ty != DataType.Text) {
                fprintf(stderr, "Schema mismatch at column %zu. Insertion failed!\n", i);
                free(new_row->values);
                free(new_row);
                return -1;
            }

            // // #value_type = values[i].ty;
            // (new_row->values[i]).ty;
            
            // new_row->values[i].ty;
        }

        return 0;
    }

    public func print(&self) {
        utils::panic("not implemented yet.");
    }

    func resize(&self, new_capacity: size_t) int {
        // printf("Resizing table %s from %d to %d\n", self->name, self->capacity, new_capacity);

        // #new_rows: Row** = cast(Row**, realloc(self->rows, new_capacity * sizeof(Row*)));
        // if (!new_rows) {
        //     utils::panic("failed to resize table rows.");
        //     return -1;
        // }

        // self->rows = new_rows;
        // self->capacity = new_capacity;

        return 0;
    }
}
