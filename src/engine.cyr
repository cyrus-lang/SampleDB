import std::libc{
    printf, fprintf, malloc,
    strncpy, free, realloc,
    stderr, strdup, memcpy
};
import std::core{panic};

MAX_TABLE_NAME_LEN: const size_t = 64;
MAX_COLUMN_NAME_LEN: const size_t = 64;
INITIAL_TABLE_CAPACITY: const size_t = 16;

public enum DataType {
    Int,
    Text
}

public union ValueData {
    int_value: int;
    text_value: char*;
}

public struct Value {
    public ty: DataType;
    public data: ValueData;
}

public struct Row { 
    public values: Value*;
}

public struct Column {
    public name: char*;
    public ty: DataType;
}

public struct Table {
    public name: char*;
    public rows: Row**;
    public schema: Column*;
    public column_count: size_t;
    public capacity: size_t;
    public row_count: size_t;

    public func create(name: char*, schema: Column*, column_count: size_t) Table* {
        if (!name || !schema || column_count == 0) {
            return null;
        }
        
        #table: Table* = malloc(sizeof(Table));
        if (!table) {
            panic("failed to allocate memory for table.");
        }

        table->name = malloc(MAX_TABLE_NAME_LEN);
        if (!table->name) {
            panic("failed to allocate memory for table name");
            free(table);
            return null;
        }
        strncpy(table->name, name, MAX_TABLE_NAME_LEN - 1);
        table->name[MAX_TABLE_NAME_LEN - 1] = '\0';

        table->column_count = column_count;
        table->capacity = INITIAL_TABLE_CAPACITY;

        table->schema = cast(Column*, malloc(sizeof(Column) * cast(size_t, column_count)));
        if (!table->schema) {
            panic("failed to allocate memory for table schema.");
            free(table);
            return null;
        }  
        
        for (#i: size_t = 0; i < column_count; i++) {
            table->schema[i].name = malloc(MAX_COLUMN_NAME_LEN);
            if (!table->schema[i].name) {
                panic("failed to allocate memory for column name");
                return null;
            }

            if (!schema[i].name) {
                panic("column name is null and cannot be copied into allocated string.");
            }
            
            strncpy(table->schema[i].name, schema[i].name, MAX_COLUMN_NAME_LEN - 1);
            table->schema[i].name[MAX_COLUMN_NAME_LEN - 1] = '\0';

            table->schema[i].ty = schema[i].ty; 
        }

        table->rows = cast(Row**, malloc(table->capacity * sizeof(Row*)));
        if (!table->rows) {
            panic("failed to allocate memory for table rows.");
            free(table->schema);
            free(table);
            return null;
        }

        return table;
    }

    public func free(&self) {
        for (#i: size_t = 0; i < self->column_count; i++) {
            free(self->schema[i].name);
        }

        free(self->rows);
        free(self->schema);
        free(self->name);
        free(self);
    }

    public func insert(&self, values: Value*) int {
        // check if we need to resize the table
        if (self->row_count >= self->capacity) {
            // double the capacity
            #new_capacity = self->capacity * 2;
            #resize_result = self->resize(new_capacity);

            if (resize_result != 0) {
                panic("failed to resize table, insertion aborted.");
                return -1;
            }
        }

        #new_row = cast(Row*, malloc(sizeof(Row)));
        if (!new_row) {
            panic("failed to allocate memory for new row.");
            return -1;
        }

        new_row->values = cast(Value*, malloc(sizeof(Value) * cast(size_t, self->column_count)));
        if (!new_row->values) {
            panic("failed to allocate memory for new row values.");
            free(new_row);
            return -1;
        }

        for (#i: size_t = 0; i < self->column_count; i++) {
            if (values[i].ty != self->schema[i].ty) {
                fprintf(stderr, "schema mismatch at column %zu. Insertion failed!\n", i);
                free(new_row->values);
                free(new_row);
                return -1;
            }

            new_row->values[i].ty = values[i].ty;
            new_row->values[i].data = values[i].data;
        }

        self->rows[self->row_count] = new_row;
        self->row_count++;

        return 0;
    }

    public func print(&self) {
        printf("Table: %s\n", self->name);

        // header

        for (#i: size_t = 0; i < 3; i++) {
            printf("%-20s", self->schema[i].name);
        }

        printf("\n");

        for (#j: size_t = 0; j < self->column_count * 20; j++)
        {
            printf("=");
        }

        printf("\n");

        // rows

        for (#z: size_t = 0; z < self->row_count; z++) {
            #row = self->rows[z];

            for (#x: size_t = 0; x < self->column_count; x++) {
                #value = row->values[x];

                switch (value.ty) {
                    case .Int:
                        printf("%-20d", value.data.int_value);
                        break;
                    case .Text:
                        printf("%-20s", value.data.text_value);
                        break;
                    default:
                        printf("%-20s", "[UNKNOWN TYPE]");
                        break;
                }
            }

            printf("\n");
        }
    }

    func resize(&self, new_capacity: size_t) int {
        printf("resizing table %s from %d to %d\n", self->name, self->capacity, new_capacity);

        #new_rows: Row** = cast(Row**, realloc(self->rows, new_capacity * sizeof(Row*)));
        if (!new_rows) {
            panic("failed to resize table rows.");
            return -1;
        }

        self->rows = new_rows;
        self->capacity = new_capacity;

        return 0;
    }
}
